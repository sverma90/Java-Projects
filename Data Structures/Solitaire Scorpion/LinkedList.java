/**
  * Solitaire Scorpion
  * LinkedList.java
  * Begins entire linked list structure
  * @version    1.0     2021-11-16
  * @author     Soumil Verma 
  * ListNode, an individual element of a Linked List.
  * @param nodeObject as String, creates a next, previous data info. of node
  * @return a node of string object
  */
public class LinkedList {
    //instance variables
    private ListNode head; 				//hold the first node (pointing to head of LL)
    private ListNode tail; 				//hold the last node (pointing to tail of LL)
    private ListNode cursor;        	//represent where I am at in the LL for printing
    private int length;					//hold length of LL (return count of # of nodes in LL)
  /**
    * constructor, sets initial head/tail to null and length to 0
    * @return null values for head/tail, length to 0
    */  
    public LinkedList() {				//assign values of head, tail, length
        this.head = null;				//list initially empty, point to null
        this.tail = null;               
        this.length = 0; 				//list length initially is 0
    }
  /**
    * cursor represents the current node in the linked list to be printed
    * getCursor returns the data at that node
    * @return cursor data as string object
    */ 
    public String getCursor() {
        if(cursor == null) { return ""; }
        return (String) cursor.data;
    }
  /**
    * Getters and Setters for constructors, generated by Eclipse
    * @param ListNode T (for sethead/settail)
    * @return head and tail values
    */   
    public ListNode getHead() { return head; }
    public ListNode getTail() { return tail; }
    public void setTail(ListNode T) { tail = T; }
    public void setHead(ListNode T) { head = T; }
  /**
    * advCursor moves the cursor to the next node for printing
    * @return head and tail values
    */
    public void advCursor() { if(cursor != null) { cursor = cursor.next; } }
  /**
    * resetCursor resets cursor to head to start printing from the beginning again
    * @return head value of cursor
    */
    public void resetCursor() { cursor = head; }
  /**
    * returns length of linked list if empty
    * @return head value is null
    */
    public boolean isEmpty() { return head == null; }
  /**
    * returns length of linked list
    * @return length of linked list
    */
    public int length() { return length; }
  /**
    * sets linked list length back to 0
    * @return sets LL length = 0
    */
    public void resetLength() { length = 0; }
  /**
    * print list in forward direction, if empty prints null
    * @return prints linked list
    */
    public String toString() {
        String s = "";
        if(head == null) { return "List is empty"; }
        ListNode temp = head; 			//temporary node, assign head to it.
        while(temp != null) {			//traverse the LL forward
            s += temp.data + " --> ";
            temp = temp.next;
        }
        s += "null";		            //will print at the end
        return s;
    }
  /**
    * Copies linked list and store it to another linked list
    * @return entire linked list
    */
    public LinkedList copy() {
        LinkedList returnList = new LinkedList();
        ListNode temp = getHead();
        while (temp != null) {
            returnList.insertLast(temp.toString());
            temp = temp.next;
        }
        return returnList;
    }
  /**
    * Copies linked list and store it to another linked list
    * @return entire linked list
    */    
    public boolean equals(LinkedList L) {
        ListNode temp1 = getHead();
        ListNode temp2 = L.getHead();
        while (temp1 != null || temp2 != null) {
            if (temp1 == null) { return false; }
            if (temp2 == null) { return false; }
            if (!temp1.equals(temp2)) { return false; }
            temp1 = temp1.next;
            temp2 = temp2.next;
        }
        return true;
    }
  /**
    * Adds first item to linked list
    * @param string String value
    * @return void
    */
    public void insertFirst(String string) {		
        ListNode newNode = new ListNode(string);	//create new node, assign value to it
        if(isEmpty()) {								//check whether empty or not.
            head = newNode;
            tail = newNode;							//assign tail to new Node
        }else {
            head.previous = newNode;
        }
        newNode.next = head;						//point new node's next pointer to head
        head = newNode;								//head point to new node
        cursor = head;								//by default it will be at head
        length++;									//increment length
    }
  /**
    * Adds last item to linked list 
    * create new node, assign value to it
    * assign head to new Node and point new node's next pointer to tail, which point to new node
    * @param value String value
    * @return void
    */
    public void insertLast(String value) {
        ListNode newNode = new ListNode(value);
        if(isEmpty()) {
            head = newNode;	
            cursor = head;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.previous = tail; 
        }
        tail = newNode; 	
        length++; 									
    }
  /**
    * findNodeAfter(7D) should return the node representing 6D
    * if it is present, null otherwise
    * @param value String value of card
    * @return null
    */
    public ListNode findNodeAfter(String card) {
        return null; // place holder
    }
}